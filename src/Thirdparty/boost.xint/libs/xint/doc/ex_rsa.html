<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>The Extended Integer (XInt) Library: RSA Encryption</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="index.html">The Extended Integer (XInt) Library</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>RSA Encryption </h1>  </div>
</div>
<div class="contents">
<p>Here is an RSA encryption example, demonstrating one possible use for the XInt library. RSA is interesting here because, to get sufficient key strength to make any effective use of it, the computer must make some mathematical calculations involving numbers that are far larger than the built-in types can handle (32 or 64 bits generally, and 128 bits at most, in today's systems). To accomplish this, the example uses <a class="el" href="structboost_1_1xint_1_1options_1_1negative__modulus.html">unsigned</a>, <a class="el" href="structboost_1_1xint_1_1options_1_1fixedlength.html">fixed-length</a> integers with <a class="el" href="structboost_1_1xint_1_1options_1_1secure.html">the secure option</a>. If you're not familiar with the RSA encryption algorithm, you can find a full explanation <a href="https://secure.wikimedia.org/wikipedia/en/wiki/RSA">on Wikipedia</a>.</p>
<p>One point of interest to the reader might be the use of a <code>callback</code> function to provide feedback to the user during the generation of the prime numbers. You might not notice it in action in this example, depending on the speed of your system, but raise the bits parameter to the <code>Rsa</code> class from 512 to 2048 and even the fastest systems at the time of this writing will take a little time to work.</p>
<p>Please note that this example, while fairly complete, is minimal. It does not include signing or verification of signatures, does nothing to prevent a known attack method (the "low encryption exponent" attack), and does not use a custom allocator (a serious implementation that was concerned with security probably would, to prevent sensitive information from being written to the system's swap file).</p>
<p>You can find this example as the file <code>rsa.cpp</code> in the <code>example</code> directory.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;sstream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;iterator&gt;</span>
<span class="preprocessor">#include &lt;boost/limits.hpp&gt;</span>
<span class="preprocessor">#include &lt;boost/integer.hpp&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="integer_8hpp.html" title="Declares the arbitrary-length integer type.">boost/xint/integer.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;boost/static_assert.hpp&gt;</span>

<span class="keyword">namespace </span>xopt = boost::xint::options;
<span class="keyword">using</span> boost::xint::callback_t;
<span class="keyword">using</span> <a class="code" href="namespaceboost_1_1xint.html#a758d415a476a5eeed28dc6b5869b1696" title="An empty callback_t, used as a default parameter for some functions.">boost::xint::no_callback</a>;

<span class="comment">// Get the number of bits in a character. It&#39;s almost certainly eight, but</span>
<span class="comment">// &quot;almost certainly&quot; doesn&#39;t cut it in portable code. We&#39;ll also specify an</span>
<span class="comment">// unsigned character instead of a signed one, so we can handle binary data</span>
<span class="comment">// safely.</span>
<span class="keyword">static</span> <span class="keyword">const</span> std::size_t cbits = std::numeric_limits&lt;unsigned char&gt;::digits;

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
<span class="keyword">class </span>Rsa {
  <span class="keyword">public</span>:
    <span class="comment">// We&#39;re going to use a fixed-length type for this example, primarily to</span>
    <span class="comment">// show how they would be used. The calculations require intermediate</span>
    <span class="comment">// results that are between two and three times the bit-size of the number</span>
    <span class="comment">// though. We&#39;ll also make it unsigned, and use secure mode to reduce the</span>
    <span class="comment">// chance that the key data gets written to disk anywhere.</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classboost_1_1xint_1_1integer__t.html" title="The integer_t class template.">boost::xint::integer_t&lt;xopt::fixedlength&lt;Bits * 3&gt;</a>,
        xopt::secure, xopt::negative_modulus&gt; KeyNumber;

    <span class="comment">// The data will rarely be an exact multiple of the number of bytes that the</span>
    <span class="comment">// encryption will return, so we need to store the original size of the data</span>
    <span class="comment">// to remove the extra bytes. We&#39;ll want the storage to take up as few bits</span>
    <span class="comment">// as possible too, so this typedef defines the smallest type that can hold</span>
    <span class="comment">// a Bits-length number of characters.</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::uint_value_t&lt;(Bits + cbits - 1) / cbits&gt;::least
        SizeT;

    <span class="comment">// We must have enough bits to handle at least one character and a SizeT...</span>
    BOOST_STATIC_ASSERT(Bits &gt; ((<span class="keyword">sizeof</span>(SizeT) + 1) * cbits));

    <span class="comment">// ...and the number of bits needs to be even.</span>
    BOOST_STATIC_ASSERT((Bits &amp; 0x01) == 0);

    Rsa(<span class="keyword">const</span> std::string keys);

    std::string publickey() <span class="keyword">const</span>;
    std::string privatekey() <span class="keyword">const</span>;

    std::string encrypt(<span class="keyword">const</span> std::string &amp;data) <span class="keyword">const</span>;
    std::string decrypt(<span class="keyword">const</span> std::string &amp;data) <span class="keyword">const</span>;

    <span class="keyword">static</span> Rsa generate(<a class="code" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547" title="A callback function takes no parameters and returns a bool.">callback_t</a> callback = <a class="code" href="namespaceboost_1_1xint.html#a758d415a476a5eeed28dc6b5869b1696" title="An empty callback_t, used as a default parameter for some functions.">no_callback</a>);

  <span class="keyword">private</span>:
    <span class="keyword">static</span> std::size_t calculate_blocksize(<span class="keyword">const</span> KeyNumber &amp;n);

    Rsa(<span class="keyword">const</span> KeyNumber _n, <span class="keyword">const</span> KeyNumber _d, <span class="keyword">const</span> KeyNumber _e);

    std::string number_to_binary_string(<span class="keyword">const</span> KeyNumber &amp;num) <span class="keyword">const</span>;
    KeyNumber binary_string_to_number(<span class="keyword">const</span> std::string &amp;s) <span class="keyword">const</span>;

    <span class="comment">// I would normally use more descriptive variable names, but these are the</span>
    <span class="comment">// traditional names for these variables. &#39;n&#39; is used as the modulus for the</span>
    <span class="comment">// public and private keys; &#39;d&#39; is the decryption (i.e. private) key</span>
    <span class="comment">// component; and &#39;e&#39; is the encryption (i.e. public) component of the key.</span>
    KeyNumber n, d, e;
    std::size_t blocksize;
};

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
std::size_t Rsa&lt;Bits&gt;::calculate_blocksize(<span class="keyword">const</span> KeyNumber &amp;n) {
    <span class="comment">// Round the size of n (in bits) down to the next lower multiple of the</span>
    <span class="comment">// number of bits in a character. That&#39;s how many characters we can fit into</span>
    <span class="comment">// a single block, for encryption purposes.</span>
    std::size_t size_in_bits = log2(n) - 1;
    <span class="keywordflow">return</span> (size_in_bits + cbits - 1) / cbits;
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
std::string Rsa&lt;Bits&gt;::number_to_binary_string(<span class="keyword">const</span> KeyNumber &amp;num)<span class="keyword"> const </span>{
    <span class="comment">// Turn a number into a binary string, using the library&#39;s binary_t type as</span>
    <span class="comment">// an intermediary.</span>
    <a class="code" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58" title="The format for the binary representations of integers.">boost::xint::binary_t</a> b = <a class="code" href="namespaceboost_1_1xint.html#af63adeb454701f4425bdd158d7f33e13" title="Creates a binary representation of an integer.">to_binary</a>(num);
    std::string s;
    std::copy(b.begin(), b.end(), std::back_inserter(s));
    <span class="keywordflow">return</span> s;
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
<span class="keyword">typename</span> Rsa&lt;Bits&gt;::KeyNumber Rsa&lt;Bits&gt;::binary_string_to_number(<span class="keyword">const</span>
    std::string &amp;s)<span class="keyword"> const</span>
<span class="keyword"></span>{
    <a class="code" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58" title="The format for the binary representations of integers.">boost::xint::binary_t</a> b;
    std::copy(s.begin(), s.end(), std::back_inserter(b));
    <span class="keywordflow">return</span> KeyNumber(b);
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
Rsa&lt;Bits&gt;::Rsa(<span class="keyword">const</span> std::string keys) {
    <span class="comment">// Make sure it&#39;s a proper key, by checking the signature.</span>
    <span class="keywordtype">bool</span> goodkey = <span class="keyword">true</span>;
    <span class="keywordflow">if</span> (keys.substr(0, 4) == <span class="stringliteral">&quot;{RSA&quot;</span>) {
        std::istringstream str(keys.substr(4));
        std::size_t recordedbits = 0;
        <span class="keywordtype">char</span> c1 = 0, c2 = 0, c3 = 0, c4 = 0;
        str &gt;&gt; recordedbits &gt;&gt; c1 &gt;&gt; e &gt;&gt; c2 &gt;&gt; n &gt;&gt; c3;
        <span class="keywordflow">if</span> (c1 == <span class="charliteral">&#39;,&#39;</span> &amp;&amp; c2 == <span class="charliteral">&#39;,&#39;</span>) {
            <span class="keywordflow">if</span> (c3 == <span class="charliteral">&#39;,&#39;</span>) {
                <span class="comment">// It&#39;s a private key, including the decryption key.</span>
                str &gt;&gt; d &gt;&gt; c4;
                <span class="keywordflow">if</span> (c4 != <span class="charliteral">&#39;}&#39;</span>) goodkey = <span class="keyword">false</span>;
            } <span class="keywordflow">else</span> {
                <span class="comment">// It&#39;s a public key, no decryption key is included.</span>
                <span class="keywordflow">if</span> (c3 != <span class="charliteral">&#39;}&#39;</span>) goodkey = <span class="keyword">false</span>;
            }
        } <span class="keywordflow">else</span> goodkey = <span class="keyword">false</span>;

        <span class="comment">// Make sure it&#39;s the right size</span>
        <span class="keywordflow">if</span> (goodkey &amp;&amp; recordedbits != Bits)
            <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">&quot;Wrong number of bits&quot;</span>);
    } <span class="keywordflow">else</span> goodkey = <span class="keyword">false</span>;

    <span class="keywordflow">if</span> (!goodkey) <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Not a valid key&quot;</span>);
    blocksize = calculate_blocksize(n);
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
Rsa&lt;Bits&gt;::Rsa(<span class="keyword">const</span> KeyNumber _n, <span class="keyword">const</span> KeyNumber _d, <span class="keyword">const</span> KeyNumber _e):
    n(_n), d(_d), e(_e)
{
    blocksize = calculate_blocksize(n);
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
std::string Rsa&lt;Bits&gt;::publickey()<span class="keyword"> const </span>{
    std::ostringstream str;
    str &lt;&lt; <span class="stringliteral">&quot;{RSA&quot;</span> &lt;&lt; Bits &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; e &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; n &lt;&lt; <span class="charliteral">&#39;}&#39;</span>;
    <span class="keywordflow">return</span> str.str();
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
std::string Rsa&lt;Bits&gt;::privatekey()<span class="keyword"> const </span>{
    std::ostringstream str;
    str &lt;&lt; <span class="stringliteral">&quot;{RSA&quot;</span> &lt;&lt; Bits &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; e &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; n &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; d &lt;&lt; <span class="charliteral">&#39;}&#39;</span>;
    <span class="keywordflow">return</span> str.str();
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
std::string Rsa&lt;Bits&gt;::encrypt(<span class="keyword">const</span> std::string &amp;data)<span class="keyword"> const </span>{
    <span class="comment">// A proper implementation would pad the message with additional random</span>
    <span class="comment">// data, to avoid the low encryption exponent attack. This example</span>
    <span class="comment">// implementation does not.</span>

    <span class="comment">// The message may contain up to (blocksize - 1) extra bytes when it&#39;s</span>
    <span class="comment">// decrypted. Prepend a SizeT with the number of bytes to remove from the</span>
    <span class="comment">// end.</span>
    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mask = (<span class="keywordtype">unsigned</span> char)(-1);
    std::string msg;
    SizeT trimblock = blocksize - ((data.length() + <span class="keyword">sizeof</span>(SizeT)) % blocksize);
    <span class="keywordflow">if</span> (trimblock == blocksize) trimblock = 0;
    <span class="keywordflow">for</span> (std::size_t i = <span class="keyword">sizeof</span>(SizeT); i &gt; 0; --i) {
        msg += <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(trimblock &amp; mask);
        trimblock &gt;&gt;= cbits;
    }
    msg += data;

    <span class="comment">// Split the message into blocks of blocksize and encrypt each one.</span>
    std::string encrypted_msg;
    <span class="keywordflow">for</span> (std::size_t block = 0; block * blocksize &lt; msg.length(); ++block) {
        <span class="comment">// Grab a block of blocksize bytes.</span>
        std::string tblock = msg.substr(block * blocksize, blocksize);

        <span class="comment">// Turn it into a KeyNumber.</span>
        KeyNumber mnumber = binary_string_to_number(tblock);

        <span class="comment">// Encrypt that number by raising it to the power of &#39;e&#39; (the public</span>
        <span class="comment">// component of the key), modulus the &#39;n&#39; component.</span>
        mnumber = <a class="code" href="namespaceboost_1_1xint.html#a0db2c9eb9e1516ebf7214e68bc6e9f10" title="Get the result of nexponent % modulus, keeping the intermediate results (relatively) small...">powmod</a>(mnumber, e, n);

        <span class="comment">// Append the encrypted data to the return value, padded to the proper</span>
        <span class="comment">// block length.</span>
        tblock = number_to_binary_string(mnumber);
        <span class="keywordflow">if</span> (tblock.length() &lt; blocksize) tblock += std::string(blocksize -
            tblock.length(), 0);
        encrypted_msg += tblock;
    }

    <span class="keywordflow">return</span> encrypted_msg;
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
std::string Rsa&lt;Bits&gt;::decrypt(<span class="keyword">const</span> std::string &amp;encrypted_msg)<span class="keyword"> const </span>{
    std::string decrypted_msg;

    <span class="comment">// Split the message into blocks of blocksize and decrypt each one.</span>
    <span class="keywordflow">for</span> (std::size_t block = 0; block * blocksize &lt; encrypted_msg.length();
        ++block)
    {
        <span class="comment">// Grab a block of blocksize bytes.</span>
        std::string tblock = encrypted_msg.substr(block * blocksize, blocksize);

        <span class="comment">// Turn it into a KeyNumber.</span>
        KeyNumber mnumber = binary_string_to_number(tblock);

        <span class="comment">// Decrypt that number by raising it to the power of &#39;d&#39; (the private</span>
        <span class="comment">// component of the key), modulus the &#39;n&#39; component.</span>
        mnumber = <a class="code" href="namespaceboost_1_1xint.html#a0db2c9eb9e1516ebf7214e68bc6e9f10" title="Get the result of nexponent % modulus, keeping the intermediate results (relatively) small...">powmod</a>(mnumber, d, n);

        <span class="comment">// Append the encrypted data to the return value, padded to the proper</span>
        <span class="comment">// block length.</span>
        tblock = number_to_binary_string(mnumber);
        <span class="keywordflow">if</span> (tblock.length() &lt; blocksize) tblock += std::string(blocksize -
            tblock.length(), 0);
        decrypted_msg += tblock;
    }

    <span class="comment">// Trim the added bytes off of it.</span>
    SizeT trimblock = 0;
    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; <span class="keyword">sizeof</span>(SizeT); ++i)
        trimblock |= (SizeT(decrypted_msg[i]) &lt;&lt; (i * cbits));
    decrypted_msg = decrypted_msg.substr(<span class="keyword">sizeof</span>(SizeT), decrypted_msg.length() -
        trimblock - <span class="keyword">sizeof</span>(SizeT));

    <span class="keywordflow">return</span> decrypted_msg;
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
Rsa&lt;Bits&gt; Rsa&lt;Bits&gt;::generate(<a class="code" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547" title="A callback function takes no parameters and returns a bool.">callback_t</a> callback) {
    <span class="comment">// Use the system&#39;s strong random number generator, via the XInt-provided</span>
    <span class="comment">// convenience class.</span>
    <a class="code" href="namespaceboost_1_1xint.html#ac38b0aafb375c80ff42b5488a52d9e8f" title="A convenience class for cryptographically-secure random numbers.">boost::xint::strong_random_generator</a> gen;

    <span class="comment">// Generate two random prime numbers, each containing no more than half of</span>
    <span class="comment">// the requested bits, and compute the product.</span>
    KeyNumber p = KeyNumber::random_prime(gen, Bits / 2, callback);
    KeyNumber q = KeyNumber::random_prime(gen, Bits / 2, callback);
    assert(p != q); <span class="comment">// If they&#39;re identical, there&#39;s almost certainly a problem</span>

    <span class="comment">// Compute the product of the primes.</span>
    KeyNumber n(p * q);

    <span class="comment">// Select an encryption key e, such that e and (p - 1) * (q - 1) are</span>
    <span class="comment">// relatively prime. Encryption goes a lot faster if you use small primes</span>
    <span class="comment">// for this value, and 65537 is recommended by X.509 and PKCS #1.</span>
    KeyNumber e(65537);

    <span class="comment">// Compute the decryption key.</span>
    KeyNumber d(<a class="code" href="namespaceboost_1_1xint.html#acda3f5ededc57f5135418a6fb70cf3d7" title="Get the modular inverse of a number in a modulus, if there is one.">invmod</a>(e, (p - 1) * (q - 1)));

    <span class="comment">// That&#39;s all we have to do. Just plug those numbers into an Rsa object and</span>
    <span class="comment">// return it.</span>
    <span class="keywordflow">return</span> Rsa&lt;Bits&gt;(n, d, e);
}



<span class="keyword">using</span> std::cout;
<span class="keyword">using</span> std::endl;
<span class="keyword">using</span> std::flush;

<span class="keyword">const</span> <span class="keywordtype">int</span> max_statusline_length = 40;

<span class="keywordtype">void</span> clearline(<span class="keywordtype">int</span> length) {
    cout &lt;&lt; <span class="charliteral">&#39;\r&#39;</span> &lt;&lt; std::string(length, <span class="charliteral">&#39; &#39;</span>) &lt;&lt; <span class="charliteral">&#39;\r&#39;</span> &lt;&lt; flush;
}

<span class="keywordtype">bool</span> callback() {
    <span class="keyword">static</span> <span class="keywordtype">int</span> n = 0;
    <span class="keywordflow">if</span> (++n == max_statusline_length) {
        clearline(max_statusline_length);
        n = 0;
    }
    cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; flush;
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}

<span class="keywordtype">int</span> main() {
    <span class="keyword">typedef</span> Rsa&lt;512&gt; Cipher;

    <span class="comment">// In this test program, we&#39;ll generate a new key every time. 512-bit keys</span>
    <span class="comment">// should generate within 100 attempts or less, most of the time, so it&#39;ll</span>
    <span class="comment">// be pretty quick. You would normally generate a new key only once, store</span>
    <span class="comment">// the private key securely, and publish the public key.</span>
    Cipher c = Cipher::generate(callback);
    clearline(max_statusline_length);

    std::string source(<span class="stringliteral">&quot;This is a test message.&quot;</span>);
    std::string encrypted = c.encrypt(source);
    std::string decrypted = c.decrypt(encrypted);

    <span class="keywordflow">if</span> (decrypted == source) {
        cout &lt;&lt; <span class="stringliteral">&quot;Decryption was successful!&quot;</span> &lt;&lt; endl &lt;&lt; endl;
        cout &lt;&lt; <span class="stringliteral">&quot;The key is: &quot;</span> &lt;&lt; c.privatekey() &lt;&lt; endl;
    } <span class="keywordflow">else</span> {
        cout &lt;&lt; <span class="stringliteral">&quot;Error in decryption!&quot;</span> &lt;&lt; endl;
        cout &lt;&lt; source &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; source.length() &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; endl;
        cout &lt;&lt; decrypted &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; decrypted.length() &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; endl;
    }

    <span class="keywordflow">return</span> EXIT_SUCCESS;
}
</pre></div> </div>
<hr>
<p><i>&copy; Copyright Chad Nelson, 2010-2011. Distributed under the Boost Software
License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
<a href=http://www.boost.org/LICENSE_1_0.txt>http://www.boost.org/LICENSE_1_0.txt</a>)
</i></p>
<p><i>Documentation generated on Wed Mar 9 2011 22:56:48 by&nbsp;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a>
1.7.1</small></address></i></p>
